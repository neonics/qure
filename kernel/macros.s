############################################################################
# Sections (.text, .data etc).

.macro .text16
	TEXTSUBSECTION = 0
	.text SECTION_CODE_TEXT16	# 0
	.code16
.endm

.macro .data16
	.text SECTION_CODE_DATA16	# 1
.endm

.macro .text16end
	.text SECTION_CODE_TEXT16_END	# 2
	.code16
.endm

.macro .text32
	TEXTSUBSECTION = 3
	.text SECTION_CODE_TEXT32	# 3
	.code32
.endm

.macro .code16_
	CODEBITS = 16
	.code16
.endm

.macro .code32_
	CODEBITS = 32
	.code32
.endm


_TLS_SIZE = 0
.macro .tdata
.struct _TLS_SIZE
.endm

.macro .tdata_end
_TLS_SIZE = .
.text32
.endm

.macro .previous
	.if TEXTSUBSECTION == 0
		.text16
	.else
	.if TEXTSUBSECTION == 3
		.text32
	.else
	.error "Unknown text subsection"
	.print TEXTSUBSECTOIN
	.endif
	.endif
	
	.ifdef CODEBITS
	.if CODEBITS == 16
		.code16
	.else
	.if CODEBITS == 32
		.code32
	.endif
	.endif
	.endif
.endm

##############################################################################
# Convenience macros

.macro PUSH_ a:vararg
	.irp v,\a
	push	\v
	.endr
.endm

.macro POP_ a:vararg
	.irp v,\a
	pop	\v
	.endr
.endm


##############################################################################
# Register macros

.macro GET_INDEX name, values:vararg
	_INDEX=-1
	_I=0

	.irp r,\values
		.ifc \r,\name
		_INDEX=_I
		.exitm
		.endif
		_I=_I+1
	.endr
.endm

.macro R8H r
	.if \r == eax
		_R8H = ah
	.endif
	.if \r == ebx
		_R8H = bh
	.endif
	.if \r == ecx
		_R8H = ch
	.endif
	.if \r == edx
		_R8H = dh
	.endif
.endm

.macro R8L r
	.if \r == eax
		_R8L = al
	.endif
	.if \r == ebx
		_R8L = bl
	.endif
	.if \r == ecx
		_R8L = cl
	.endif
	.if \r == edx
		_R8L = dl
	.endif
.endm

.macro R16 r
	.if \r == eax
		_R16 = ax
	.endif
	.if \r == ebx
		_R16 = bx
	.endif
	.if \r == ecx
		_R16 = cx
	.endif
	.if \r == edx
		_R16 = dx
	.endif
.endm


# assigns to var a register that is not r1 or r2, from eax, ebx, ecx.
.macro REG_GET_FREE var, r1, r2
	.if eax==\r1
		.if ebx==\r2
			\var = ecx
		.else
			\var = ebx
		.endif
	.elseif eax==\r2
		.if ebx==\r1
			\var = ecx
		.else
			\var = ebx
		.endif
	.endif
.endm

.macro IS_REG8 var, val
	GET_INDEX \val, al,ah,bl,bh,cl,ch,dl,dh
	\var = _INDEX >= 0
.endm

.macro IS_SEGREG var, val
	GET_INDEX \val, cs,ds,es,ss,fs,gs
	\var = _INDEX >= 0
.endm

.macro IS_REG32 var, val
	GET_INDEX \val, eax,ebx,ecx,edx,esi,edi,ebp,esp,cs,ds,es,fs,gs,ss
	\var = _INDEX >= 0
.endm

# gets the 32 bit register name for the 8 or 16 bit 'val' name
.macro GET_REG32 var, val
	GET_INDEX \val, al,ah,bl,bh,cl,ch,dl,dh
	.if _INDEX >=0
		_INDEX = _INDEX / 2
	.else
	GET_INDEX \val, ax,bx,cx,dx,si,di,bp,sp
	.endif

	.if _INDEX >= 0
	_COUNT = 0
	.irp \var, eax,ebx,ecx,edx,esi,edi,ebp,esp
		.if _COUNT == _INDEX
		.exitm 3 # doesn't exit the entire macro, only .irp
		.endif
		_COUNT = _COUNT + 1
	.endr
	.endif

	# ... hence this check:
	.if _COUNT != _INDEX
	.error "\val: must be reg8 or reg16 and not segment register"
	.endif
.endm


##############################################################################
# opcodes

INTEL_ARCHITECTURE = 6	# 386 (32 bit)

.if INTEL_ARCHITECTURE < 6
##########################################
## Generated by util/genopcodemacros.pl ##

.macro cmov cond, invcond, src, dst
	.if INTEL_ARCHITECTURE >= 6
		cmov\cond	\src, \dst
	.else
		j\invcond	600f
		mov	\src, \dst
600:
	.endif
.endm
.macro cmove src, dst
	cmov e, ne, \src, \dst
.endm
cmovz=cmove
.macro cmovne src, dst
	cmov ne, e, \src, \dst
.endm
cmovnz=cmovne
.macro cmova src, dst
	cmov a, be, \src, \dst
.endm
cmovnbe=cmova
.macro cmovbe src, dst
	cmov be, a, \src, \dst
.endm
cmovna=cmovbe
.macro cmovae src, dst
	cmov ae, b, \src, \dst
.endm
cmovnb=cmovae
.macro cmovb src, dst
	cmov b, ae, \src, \dst
.endm
cmovnae=cmovb
.macro cmovg src, dst
	cmov g, le, \src, \dst
.endm
cmovnle=cmovg
.macro cmovle src, dst
	cmov le, g, \src, \dst
.endm
cmovng=cmovle
.macro cmovge src, dst
	cmov ge, l, \src, \dst
.endm
cmovnl=cmovge
.macro cmovl src, dst
	cmov l, ge, \src, \dst
.endm
cmovnge=cmovl
.macro cmovp src, dst
	cmov p, np, \src, \dst
.endm
cmovpe=cmovp
.macro cmovnp src, dst
	cmov np, p, \src, \dst
.endm
cmovpo=cmovnp
.macro cmovc src, dst
	cmov c, nc, \src, \dst
.endm
.macro cmovnc src, dst
	cmov nc, c, \src, \dst
.endm
.macro cmovo src, dst
	cmov o, no, \src, \dst
.endm
.macro cmovno src, dst
	cmov no, o, \src, \dst
.endm
.macro cmovs src, dst
	cmov s, ns, \src, \dst
.endm
.macro cmovns src, dst
	cmov ns, s, \src, \dst
.endm

## end of generated code #####
##############################
.endif
