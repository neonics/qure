.ifndef __MACROS_INCLUDED
__MACROS_INCLUDED=1
############################################################################
# Sections (.text, .data etc).


# realmode section separation:
#   0 = put realmode code, data at beginning of .text
#   1 = create .text16/.data16 section
REALMODE_SEP = 1

.ifndef ELF
.error "Please assemble with '--defsym ELF=1' or '--defsym ELF=0'"
.endif

.if REALMODE_SEP
	.if ELF
		.macro .text16
			.section ".text16", "ax"
			.code16
		.endm

		.macro .data16 sub=0
			.section ".data16", "aw"
			.ifnc \sub,0
			.subsection \sub
			.endif
		.endm
	.else

	TEXT16 = .text16

	.macro .text16
		.section .text16, "rwx"	###
		.code16
	.endm

	TEXT16 = .text #.text16

	.macro .data16 sub=0
		.section .data16, "rwd"	###
		.ifnc \sub,0
		.section .data16, \sub
		.endif
		.code16
	.endm

	.macro .text16end
		.section .text16, 99		###
		.code16
	.endm

	.macro .data16end
		.section .data16, 99		###
		.code16
	.endm

	.endif

.else

	TEXT16 = .text

	.macro .text16
		.text SECTION_CODE_TEXT16	# 0
		.code16
	.endm


	.macro .data16
		.text SECTION_CODE_DATA16	# 1
		.code16
	.endm

	.macro .text16end
		.text SECTION_CODE_TEXT16_END	# 2
		.code16
	.endm

	.macro .text16end
		.text SECTION_DATA16_end
		.code16
	.endm

.endif


.macro .text32
	.text SECTION_CODE_TEXT32	# 3
	.code32
.endm

.macro .code16_
	CODEBITS = 16
	.code16
.endm

.macro .code32_
	CODEBITS = 32
	.code32
.endm


_TLS_SIZE = 0
.macro .tdata
.struct _TLS_SIZE
.endm

.macro .tdata_end
_TLS_SIZE = .
.text32
.endm

##############################################################################
# Convenience macros

.macro PUSH_ a:vararg
	.irp v,\a
	push	\v
	.endr
.endm

.macro POP_ a:vararg
	.irp v,\a
	pop	\v
	.endr
.endm


.macro LOOP_ label
	.if \label < .
	_TMP_DISTANCE = . - \label
	.else
	_TMP_DISTANCE = \label - .
	.endif
	.if _TMP_DISTANCE > 127
	dec	ecx
	jnz	\label
	.else
	loop	\label
	.endif
.endm

##############################################################################
# Register macros

.macro GET_INDEX name, values:vararg
	_INDEX=-1
	_I=0

	.irp r,\values
		.ifc \r,\name
		_INDEX=_I
		.exitm
		.endif
		_I=_I+1
	.endr
.endm

.macro R8H r
	GET_INDEX \r, eax,ebx,ecx,edx
	.if _INDEX < 0
		.error "\r must be one of eax,ebx,ecx,edx"
	.endif
	.if \r == eax
		_R8H = ah
	.endif
	.if \r == ebx
		_R8H = bh
	.endif
	.if \r == ecx
		_R8H = ch
	.endif
	.if \r == edx
		_R8H = dh
	.endif
.endm

.macro R8L r
	GET_INDEX \r, eax,ebx,ecx,edx
	.if _INDEX < 0
		.error "\r must be one of eax,ebx,ecx,edx"
	.endif
	.if \r == eax
		_R8L = al
	.endif
	.if \r == ebx
		_R8L = bl
	.endif
	.if \r == ecx
		_R8L = cl
	.endif
	.if \r == edx
		_R8L = dl
	.endif
.endm

.macro R16 r
	.if \r == eax
		_R16 = ax
	.endif
	.if \r == ebx
		_R16 = bx
	.endif
	.if \r == ecx
		_R16 = cx
	.endif
	.if \r == edx
		_R16 = dx
	.endif
	.if \r == esi
		_R16 = si
	.endif
	.if \r == edi
		_R16 = di
	.endif
	.if \r == ebp
		_R16 = bp
	.endif
	.if \r == esp
		_R16 = sp
	.endif
.endm


# assigns to var a register that is not r1 or r2, from eax, ebx, ecx.
.macro REG_GET_FREE var, r1, r2
	.if eax==\r1
		.if ebx==\r2
			\var = ecx
		.else
			\var = ebx
		.endif
	.elseif eax==\r2
		.if ebx==\r1
			\var = ecx
		.else
			\var = ebx
		.endif
	.endif
.endm

.macro IS_REG8 var, val
	GET_INDEX \val, al,ah,bl,bh,cl,ch,dl,dh
	\var = _INDEX >= 0
.endm

.macro IS_SEGREG var, val
	GET_INDEX \val, cs,ds,es,ss,fs,gs
	\var = _INDEX >= 0
.endm

.macro IS_REG16 var, val
	GET_INDEX \val, ax,bx,cx,dx,si,di,bp,sp,cs,ds,es,fs,gs,ss
	\var = _INDEX >= 0
.endm


.macro IS_REG32 var, val
	GET_INDEX \val, eax,ebx,ecx,edx,esi,edi,ebp,esp,cs,ds,es,fs,gs,ss
	\var = _INDEX >= 0
.endm

# gets the 32 bit register name for the 8 or 16 bit 'val' name
.macro GET_REG32 var, val
	GET_INDEX \val, al,ah,bl,bh,cl,ch,dl,dh
	.if _INDEX >=0
		_INDEX = _INDEX / 2
	.else
	GET_INDEX \val, ax,bx,cx,dx,si,di,bp,sp
	.endif

	.if _INDEX >= 0
	_COUNT = 0
	.irp tmp, eax,ebx,ecx,edx,esi,edi,ebp,esp
		.if _COUNT == _INDEX
			\var = \tmp
		.exitm 3 # doesn't exit the entire macro, only .irp
		.endif
		_COUNT = _COUNT + 1
	.endr
	.endif

	# ... hence this check:
	.if _COUNT != _INDEX
	.error "\val: must be reg8 or reg16 and not segment register"
	.endif
.endm


##############################################################################
# opcodes

INTEL_ARCHITECTURE = 6	# 386 (32 bit)

.if INTEL_ARCHITECTURE < 6
##########################################
## Generated by util/genopcodemacros.pl ##

.macro cmov cond, invcond, src, dst
	.if INTEL_ARCHITECTURE >= 6
		cmov\cond	\src, \dst
	.else
		j\invcond	600f
		mov	\src, \dst
600:
	.endif
.endm
.macro cmove src, dst
	cmov e, ne, \src, \dst
.endm
cmovz=cmove
.macro cmovne src, dst
	cmov ne, e, \src, \dst
.endm
cmovnz=cmovne
.macro cmova src, dst
	cmov a, be, \src, \dst
.endm
cmovnbe=cmova
.macro cmovbe src, dst
	cmov be, a, \src, \dst
.endm
cmovna=cmovbe
.macro cmovae src, dst
	cmov ae, b, \src, \dst
.endm
cmovnb=cmovae
.macro cmovb src, dst
	cmov b, ae, \src, \dst
.endm
cmovnae=cmovb
.macro cmovg src, dst
	cmov g, le, \src, \dst
.endm
cmovnle=cmovg
.macro cmovle src, dst
	cmov le, g, \src, \dst
.endm
cmovng=cmovle
.macro cmovge src, dst
	cmov ge, l, \src, \dst
.endm
cmovnl=cmovge
.macro cmovl src, dst
	cmov l, ge, \src, \dst
.endm
cmovnge=cmovl
.macro cmovp src, dst
	cmov p, np, \src, \dst
.endm
cmovpe=cmovp
.macro cmovnp src, dst
	cmov np, p, \src, \dst
.endm
cmovpo=cmovnp
.macro cmovc src, dst
	cmov c, nc, \src, \dst
.endm
.macro cmovnc src, dst
	cmov nc, c, \src, \dst
.endm
.macro cmovo src, dst
	cmov o, no, \src, \dst
.endm
.macro cmovno src, dst
	cmov no, o, \src, \dst
.endm
.macro cmovs src, dst
	cmov s, ns, \src, \dst
.endm
.macro cmovns src, dst
	cmov ns, s, \src, \dst
.endm

## end of generated code #####
##############################
.endif
.endif
